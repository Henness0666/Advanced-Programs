-- Advanced Ore Finder by Henness
-- Version 2.0 12/16/2012

-- Config
Version = "v2.0"

-- Functions
function version()
	return Version
end

function skip()
	local id, key = os.pullEvent("key")
end

function saveTable(table,name)
	local file = fs.open(name,"w")
	file.write(textutils.serialize(table))
	file.close()
end

function loadTable(name)
	local file = fs.open(name,"r")
	local data = file.readAll()
	file.close()
	return textutils.unserialize(data)
end

function save()
	ofsave = {
		["currentPos"] = {
			["x"] = x, ["y"] = y, ["z"] = y, ["face"] = face
		},
		["W"] = width,
		["L"] = length,
		["w"] = w,
		["l"] = l
	}
	saveTable(ofsave, "ofsave")
end

function turnLeft(a)
	if not a then
		a = 1
	end
	for i=1,math.abs(a),1 do
		turtle.turnLeft()
		if face==0 then
			face=3
		else
			face=face-1
		end
		save()
	end
	return true
end

function turnRight(a)
	if not a then
		a = 1
	end
	for i=1,math.abs(a),1 do
		turtle.turnRight()
		if face==3 then
			face=0
		else
			face=face+1
		end
		save()
	end
	return true
end

function face(a)
	local turn = face-a
	local done = false
	if face == a then
		done = true
	elseif turn == -1 or turn == 3 then
		turnRight()
		done = true
	elseif turn == 1 or turn == -3 then
		turnLeft()
		done = true
	elseif math.abs(turn) == 2 then
		turnRight(2)
		done = true
	end
	return done
end

function up(n) -- Moves the turtle up "n" distance
	local moved
	if not n then
		n=1
	end
	if y<255 then
		for k=1,n,1 do
			moved = turtle.up()
			if moved then
				y=y+1
				save()
			else
				break
			end
		end
	end
	return moved
end

function down(n) -- Moves the turtle down "n" distance
	local moved
	if not n then
		n=1
	end
	if y>1 then
		for k=1,n,1 do
			moved = turtle.down()
			if moved then
				y=y-1
				save()
			else
				break
			end
		end
	end
	return moved
end

function forward(n) -- Moves the turtle forward "n" distance
	local moved
	if not n then
		n=1
	end
	if face==0 then
		for k=1,n,1 do
			moved=turtle.forward()
			if moved then
				z=z+1
				save(0
			else
				break
			end
		end
	elseif face==1 then
		for k=1,n,1 do
			moved=turtle.forward()
			if moved then
				x=x-1
				save()
			else
				break
			end
		end
	elseif face==2 then
		for k=1,n,1 do
			moved=turtle.forward()
			if moved then
				z=z-1
				save()
			else
				break
			end
		end
	elseif face==3 then
		for k=1,n,1 do
			moved=turtle.forward()
			if moved then
				x=x+1
				save()
			else
				break
			end
		end
	end
	return moved
end

function dig()
	return turtle.dig()
end

function digDown()
	return turtle.digDown()
end

function digUp()
	return turtle.digUp()
end

function compareForward(endSlot,startSlot)
	if not startSlot then
		startSlot=2
	end
	if not endSlot then
		endSlot=ignore
	end
	Ore=true
	for i=startSlot,endSlot,1 do
		turtle.select(i)
		if turtle.compare() then
			Ore = false
			break
		end				
	end
	if Ore then
		turtle.dig()
	end
end

function findDown(n) -- Finds all ores bellow the turtle for "n" distance
	if not n then
		n=y-1
	end
	for i=1,n,1 do
		moved=down()
		if not moved and turtle.detectDown() then
			digDown()
			if not down() then
				break
			end
		elseif not moved and not turtle.detectDown() then
			repeat
				turtle.attackDown()
			until down()
		end
		for j=1,4,1 do
			compareForward()
			turnRight()
		end
	end
end

function moveToPos(A, B, C, face)
	a=A-x
	b=B-y
	c=C-z
	if b<0 then
		for i=1,math.abs(b),1
			moved=down()
			if not moved and turtle.detectDown() then
				repeat
					digDown()
				until down()
			elseif not moved and not turtle.detectDown() then
				repeat
					turtle.attackDown()
				until down()
			end
		end
	elseif b>0 then
		for i=1,math.abs(b),1
			moved=up()
			if not moved and turtle.detectUp() then
				repeat
					digUp()
				until up()
			elseif not moved and not turtle.detectUp() then
				repeat
					turtle.attackUp()
				until up()
			end
		end
	end
	if a<0 then
		face()
	elseif a>0 then
		face()
	end
	if a ~= 0 then
		for i=1,math.abs(a),1
			moved=forward()
			if not moved and turtle.detect() then
				repeat
					dig()
				until forward()
			elseif not moved and not turtle.detect() then
				repeat
					turtle.attack()
				until forward()
			end
		end
	end
	if c<0 then
		face()
	elseif c>0 then
		face()
	end
	if c ~= 0 then
		for i=1,math.abs(c),1
			moved=forward()
			if not moved and turtle.detect() then
				repeat
					dig()
				until forward()
			elseif not moved and not turtle.detect() then
				repeat
					turtle.attack()
				until forward()
			end
		end
	end
	face(face)
	if x,y,z == A,B,C then
		return true
	else
		return false
	end
end

function checkReturn()
	if turtle.getFuelLevel() < 2*y+W+L then
		moveToPos(ofsave["startPos"]["x"],ofsave["startPos"]["y"],ofsave["startPos"]["z"],faceB)
		for i=ignore+2,16,1 do
			turtle.select(i)
			turtle.drop()
		end
		turtle.select(1)
		repeat
			if turtle.getItemCount(1) > 1 then
				turtle.refuel(1)
			end
			sleep(0.1)
		until turtle.getFuelLevel() > 2*y+W+L
		moveToPos(ofsave["returnPos"]["x"], ofsave["returnPos"]["y"], ofsave["returnPos"]["z"], ofsave["returnPos"]["face"])
	elseif turtle.getItemCount(16) > 0 then
		moveToPos(ofsave["startPos"]["y"], ofsave["startPos"]["y"],ofsave["startPos"]["z"],faceB)
		for i=ignore+2,16,1 do
			turtle.select(i)
			turtle.drop()
		end
		moveToPos(ofsave["returnPos"]["x"], ofsave["returnPos"]["y"], ofsave["returnPos"]["z"], ofsave["returnPos"]["face"])
	end
end

function oreFinder()
	for l=ofsave["l"],L=ofsave["L"] do
		for w=ofsave["w"],W=ofsave["W"] do
			ofsave = {["returnPos"] = {["x"] = x, ["y"] = y, ["z"] = z, ["face"] = face}, ["l"] = l, ["w"] = w, ["L"] = L, ["W"] = W}
			checkReturn()
			if math.fmod((ofsave["returnPos"]["x"]+4)-2(ofsave["returnPos"]["z"]-1), 5) == 0 then
				findDown()
				moveToPos(ofsave["returnPos"]["x"], ofsave["returnPos"]["y"], ofsave["returnPos"]["z"], ofsave["returnPos"]["face"])
			end
			if ofsave["w"] == ofsave["W"] then
				if face == faceF then
					turnRight()
					ofsave = {["right"] = true}
				elseif face == faceB then 
					turnLeft()
					ofsave = {["left"] = true}
				end
				ofsave = {["returnPos"] = {["x"] = x, ["y"] = y, ["z"] = z, ["face"] = face}}
			end
			if not ofsave["forward"] then
				moved=forward()
				if not moved and turtle.detect() then
					repeat dig() until forward()
				elseif not moved and not turtle.detect() then
					repeat turtle.attack() until forward()
				end
				ofsave = {["returnPos"] = {["x"] = x, ["y"] = y, ["z"] = z, ["face"] = face}, ["forward"] = true}
			end
			if ofsave["right"] then
				turnRight()
				ofsave = {["right"] = false}
			elseif ofsave["left"] then
				turnLeft()
				ofsave = {["left"] = false}
			end
			ofsave = {["returnPos"] = {["x"] = x, ["y"] = y, ["z"] = z, ["face"] = face},["forward"] = false}
		end
		ofsave["w"] = 1
	end
	fs.delete(ofsave)
end

function runOreFinder(width, length, ignore)
	if width and length then
		local ofsave = {
			["startPos"] = {
				["x"] = x, ["y"] = y, ["z"] = z, ["face"] = face
			},
			["currentPos"] = {
				["x"] = x, ["y"] = y, ["z"] = y, ["face"] = face
			},
			["returnPos"] = {
				["x"] = x, ["y"] = y, ["z"] = z, ["face"] = face
			},
			["ignore"] = ignore,
			["forward"] = false,
			["left"] = false,
			["right"] = false,
			["W"] = width,
			["L"] = length,
			["w"] = 1,
			["l"] = 1
		}
		if fs.exists("ofsave") then
			fs.delete("ofsave")
		end
		saveTable(ofsave, "ofsave")
	else
		local ofsave = loadTable(ofsave)
		moveToPos(ofsave["returnPos"]["x"], ofsave["returnPos"]["y"], ofsave["returnPos"]["z"], ofsave["returnPos"]["face"])
	end
	local faceF = ofsave["startPos"]["face"]
	if ofsave["startPos"]["face"]<=1 then
		local faceB = ofsave["startPos"]["face"]+2
	else 
		local faceB = ofsave["startPos"]["face"]-2
	end
	parallel.waitForAny(orefinder, skip)
end

local tArgs = { ... }
if #tArgs > 0 then
	width = tArgs[1]
	length = tArgs[2]
	ignore = tArgs[3]
end
runOreFinder(width, length, ignore)